returnVal4 <- length(string);
steps_left <- length(string);
for(step in 1:length(string)) { if (x==11 & y==11) {  returnVal4 <- 0 - ((length(string) - step)/10);
break
} else if (round(string[step],0)==1 & lab1[x-1,y]==0) { x <- (x - 1) ; steps_left <- steps_left - step
} else if (round(string[step],0)==2 & lab1[x+1,y]==0) { x <- (x + 1) ; steps_left <- steps_left - step
} else if (round(string[step],0)==3 & lab1[x,y+1]==0) { y <- (y + 1) ; steps_left <- steps_left - step
} else if (round(string[step],0)==4 & lab1[x,y-1]==0) { y <- (y - 1) ; steps_left <- steps_left - step
} else steps_left <- steps_left - step ; next
}
returnVal4 <- (length(string)/2 + 2 - x - y);
returnVal4;
}
evaluate4(v_exit)
evaluate3(v_exit)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=100,
mutationChance=0.1,
elitism=TRUE,
monitorFunc=NULL, evalFunc=evaluate4,
showSettings=FALSE, verbose=FALSE)
summary(genalg_lab4, echo=T)
plot(genalg_lab4)
plot(genalg_lab3)
plot(genalg_lab1)
genalg_lab4$best
labyrinth
lab2 <- lab1
lab2
lab1 <- labyrinth
# genalg
genalg_lab1 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=100,
mutationChance=0.1,
elitism=TRUE,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_lab1)
genalg_lab1$best
plot(genalg_lab1)
summary(genalg_lab1, echo=T)
labyrinth
lab1 <- lab2
lab1
summary(genalg_lab1)
summary(genalg_lab1)
summary(genalg_lab1, echo=T)
wyniczek <- round(summary(genalg_lab1),0)
summary(genalg_lab1)[1]
summary(genalg_lab1)
summary(genalg_lab1)
summary(genalg_lab1)[]
summary(genalg_lab1, echo=T)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=0.1,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
returnVal3 <- 22;
for(step in 1:40) { if (x==11 & y==11) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & lab1[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & lab1[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & lab1[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & lab1[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (22 - x - y);
returnVal3
}
evaluate3(v_exit)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=0.1,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
returnVal3 <- 22;
for(step in 1:40) { if (x==11 & y==11) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & lab1[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & lab1[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & lab1[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & lab1[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (22 - x - y);
returnVal3
}
evaluate3(v_exit)
# genalg
genalg_lab1 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=100,
mutationChance=0.1,
elitism=TRUE,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_lab1)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=0.1,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=F,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_lab4)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=0.2,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_lab4)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=50, iters=50,
mutationChance=0.2,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_lab4)
plot(genalg_lab4)
summary(genalg_lab4, echo=T)
plot(genalg_lab4)
genalg_lab4 <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=50, iters=70,
mutationChance=0.2,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_lab4)
system.time(rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=50, iters=70,
mutationChance=0.2,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE))
system.time(rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=70,
mutationChance=0.2,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE))
{
lab15_v <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
lab15 <- matrix(data=lab15_v, nrow = 17, ncol = 17)
}
labyrinth <- lab15
library(pheatmap)
pheatmap(labyrinth, cellwidth = 15,
cellheight = 15,
cluster_row = FALSE,
cluster_col = FALSE,
color=gray.colors(2,start=1,end=0))
{
lab10 <- matrix(nrow=12,ncol=12);
lab10[1,] <- 1; lab10[12,] <- 1; lab10[,1] <- 1; lab10[,12] <- 1;
#fill the inner of the labyrinth from example
lab10[2, 2:11] <- c(0,0,0,1,0,0,0,1,0,0)
lab10[3, 2:11] <- c(1,1,0,0,0,1,0,1,1,0)
lab10[4, 2:11] <- c(0,0,0,1,0,1,0,0,0,0)
lab10[5, 2:11] <- c(0,1,0,1,1,0,0,1,1,0)
lab10[6, 2:11] <- c(0,0,1,1,0,0,0,1,0,0)
lab10[7, 2:11] <- c(0,0,0,0,0,1,0,0,0,1)
lab10[8, 2:11] <- c(0,1,0,0,1,1,0,1,0,0)
lab10[9, 2:11] <- c(0,1,1,1,0,0,0,1,1,0)
lab10[10,2:11] <- c(0,1,0,1,1,0,1,0,1,0)
lab10[11,2:11] <- c(0,1,0,0,0,0,0,0,0,0)
}
{
lab20 <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
dim(lab20) <- c(22,22)
}
labyrinth <- lab10
# set the variable for the size of choosen labyrinth
lab_size <- nrow(labyrinth) - 2; lab_size
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
exit_coordinates <- lab_size * 2 + 2;
returnVal3 <- exit_coordinates;
for(step in 1:40) { if (x==11 & y==11) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & labyrinth[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & labyrinth[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & labyrinth[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & labyrinth[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (exit_coordinates - x - y);
returnVal3
}
# set the min and max values for the genes of float chromosome
# for rbga function
lab_size
vMin <- rep(0.51, lab_size * 4); vMax <- rep(4.49, lab_size * 4)
library(genalg)
genalg_labyrinth <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=200,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_labyrinth)
system.time(
rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=200,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
)
genalg2_labyrinth$best
plot(genalg_labyrinth)
genalg_labyrinth$best
plot(genalg_labyrinth)
genalg_labyrinth$best
# or create matrix with results for different popsize and iterations number
{
rbga_results <- (matrix(data = NA, nrow = lab_size, ncol = 6))
colnames(rbga_results) <- c("pop&iter", "user", "system", "time", '5', '6' )
for (i in 1:lab_size) {
rbga_results[i,] <- c(i * lab_size, system.time(
rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=lab_size*i, iters=lab_size*i,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
))
}
rbga_results
}
# plot the results
plot(rbga_results[,c(1,4)],
type = "b",
col = "red",
main = "Genethic algorithm efficiency according to population size and iterations number",
xlab = "Population size and iterations number for rbga method"
)
labyrinth <- lab15
pheatmap(labyrinth, cellwidth = 15,
cellheight = 15,
cluster_row = FALSE,
cluster_col = FALSE,
color=gray.colors(2,start=1,end=0))
# set the variable for the size of choosen labyrinth
lab_size <- nrow(labyrinth) - 2; lab_size
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
exit_coordinates <- lab_size * 2 + 2;
returnVal3 <- exit_coordinates;
for(step in 1:40) { if (x==11 & y==11) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & labyrinth[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & labyrinth[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & labyrinth[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & labyrinth[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (exit_coordinates - x - y);
returnVal3
}
vMin <- rep(0.51, lab_size * 4); vMax <- rep(4.49, lab_size * 4)
genalg_labyrinth <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=200,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_labyrinth)
genalg_labyrinth$best
# or create matrix with results for different popsize and iterations number
{
rbga_results <- (matrix(data = NA, nrow = lab_size, ncol = 6))
colnames(rbga_results) <- c("pop&iter", "user", "system", "time", '5', '6' )
for (i in 1:lab_size) {
rbga_results[i,] <- c(i * lab_size, system.time(
rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=lab_size*i, iters=lab_size*i,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
))
}
rbga_results
}
# plot the results
plot(rbga_results[,c(1,4)],
type = "b",
col = "red",
main = "Genethic algorithm efficiency according to population size and iterations number",
xlab = "Population size and iterations number for rbga method"
)
{
pdf(file = "genalg_results_lab15.pdf",
#      width=6,
height=4,
paper='a4r',
pagecentre = T,
onefile = F)
plot(rbga_results[,c(1,4)],
type = "b",
col = "red",
main = "Genalg efficiency according to population size and iterations number",
xlab = "Population size and iterations number for rbga method"
)
dev.off()
}
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
exit_coordinates <- lab_size * 2 + 2;
returnVal3 <- exit_coordinates;
for(step in 1:40) { if (x==lab_size + 1 & y==lab_size + 1) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & labyrinth[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & labyrinth[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & labyrinth[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & labyrinth[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (exit_coordinates - x - y);
returnVal3
}
vMin <- rep(0.51, lab_size * 4); vMax <- rep(4.49, lab_size * 4)
genalg_labyrinth <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=100, iters=100,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_labyrinth)
genalg_labyrinth$best
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
exit_coordinates <- lab_size * 2 + 2;
returnVal3 <- exit_coordinates_sum;
for(step in 1:length(string)) { if (x==lab_size + 1 & y==lab_size + 1) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & labyrinth[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & labyrinth[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & labyrinth[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & labyrinth[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (exit_coordinates_sum - x - y);
returnVal3
}
vMin <- rep(0.51, lab_size * 4); vMax <- rep(4.49, lab_size * 4)
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
exit_coordinates <- lab_size * 2 + 2;
returnVal3 <- exit_coordinates_sum;
for(step in 1:length(string)) { if (x==lab_size + 1 & y==lab_size + 1) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & labyrinth[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & labyrinth[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & labyrinth[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & labyrinth[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (exit_coordinates_sum - x - y);
returnVal3
}
genalg_labyrinth <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=200,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
evaluate3 <- function(string=c()) {
x <- 2;
y <- 2;
exit_coordinates_sum <- lab_size * 2 + 2;
returnVal3 <- exit_coordinates_sum;
for(step in 1:length(string)) { if (x==lab_size + 1 & y==lab_size + 1) { returnVal2 = 0; break
} else if (round(string[step],0)==1 & labyrinth[x-1,y]==0) { x <- (x - 1)
} else if (round(string[step],0)==2 & labyrinth[x+1,y]==0) { x <- (x + 1)
} else if (round(string[step],0)==3 & labyrinth[x,y+1]==0) { y <- (y + 1)
} else if (round(string[step],0)==4 & labyrinth[x,y-1]==0) { y <- (y - 1)
} else next
}
returnVal3 <- (exit_coordinates_sum - x - y);
returnVal3
}
genalg_labyrinth <- rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=200, iters=200,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
plot(genalg_labyrinth)
# or create matrix with results for different popsize and iterations number
{
rbga_results <- (matrix(data = NA, nrow = lab_size, ncol = 6))
colnames(rbga_results) <- c("pop&iter", "user", "system", "time", '5', '6' )
for (i in 1:lab_size) {
rbga_results[i,] <- c(i * lab_size, system.time(
rbga(stringMin=vMin, stringMax=vMax,
suggestions=NULL,
popSize=lab_size*i, iters=lab_size*i,
mutationChance=0.1,
elitism=T,
monitorFunc=NULL, evalFunc=evaluate3,
showSettings=FALSE, verbose=FALSE)
))
}
rbga_results
}
# plot the results
plot(rbga_results[,c(1,4)],
type = "b",
col = "red",
main = "Genethic algorithm efficiency according to population size and iterations number",
xlab = "Population size and iterations number for rbga method"
)
setwd("D:\Mgr_Inf\Rstudio\LAB3_data_mining")
setwd("D:/Mgr_Inf/Rstudio/LAB3_data_mining")
? Sdev1 = 1.7124583
install.packages(“Hmisc”)
install.packages(“Hmisc”)
dirty_iris <- read.csv("D:/Mgr_Inf/Rstudio/LAB3_data_mining/dirty_iris.csv")
View(dirty_iris)
a = subset(dirty.iris, is.finite(Sepal.Length) & is.finite(Sepal.Width) & is.finite(Petal.Length) & is.finite(Petal.Width))
a = subset(dirty.iris, is.finite(Sepal.Length) & is.finite(Sepal.Width) & is.finite(Petal.Length) & is.finite(Petal.Width))
View(dirty_iris)
dirty.iris <- read.csv("dirty_iris.csv", header=TRUE, sep=",")
a = subset(dirty.iris, is.finite(Sepal.Length) & is.finite(Sepal.Width) & is.finite(Petal.Length) & is.finite(Petal.Width))
E <- editset(c("Sepal.Length <= 30", "Species %in% c('setosa','versicolor','virginica')"))
library(editrules)
import.packages("editrules")
install.packages("editrules")
library(editrules)
a = subset(dirty.iris, is.finite(Sepal.Length) & is.finite(Sepal.Width) & is.finite(Petal.Length) & is.finite(Petal.Width))
E <- editset(c("Sepal.Length <= 30", "Species %in% c('setosa','versicolor','virginica')"))
E <- editset(c("Sepal.Length <= 30", "Species %in% c('setosa','versicolor','virginica')", "Sepal.Length>0", "Sepal.Width>0", "Petal.Length > 0", "Petal.Width>0", "Petal.Length >= 2* Petal.Width", "Sepal.Length > Petal.Length"))
E <- editset(c("Sepal.Length <= 30", "Species %in% c('setosa','versicolor','virginica')", "Sepal.Length>0", "Sepal.Width>0", "Petal.Length > 0", "Petal.Width>0", "Petal.Length >= 2* Petal.Width", "Sepal.Length > Petal.Length"))
E
summary(ve)
ve <- violatedEdits(E, dirty.iris) ; ve
summary(ve)
install.packages("deducorrect")
plot(ve)
library(deducorrect)
R <- correctionRules("rules.txt")
corrected.dirty.iris <- correctWithRules(R, dirty.iris)
corrected <- corrected.dirty.iris$corrected
corrected
install.packages(“Hmisc”)
#b)
install.packages(“VIM”)
install.packages(“Hmisc”)
install.packages("Hmisc")
library(Hmisc)
cbind.data.frame(Sepal.Length=impute(corrected$Sepal.Length, mean), Sepal.Width=impute(corrected$Sepal.Width, mean), Petal.Length=impute(corrected$Petal.Length, mean), Petal.Width=impute(corrected$Petal.Width, mean), corrected$Species)
#b)
install.packages("VIM")
library(VIM)
clean.iris.knn <- kNN(corrected)
clean.iris.knn.2 <- kNN(corrected)[1:5]
# a)
iris
# b)
iris.log <- cbind.data.frame(Sepal.Length=log(iris$Sepal.Length), Sepal.Width=log(iris$Sepal.Width), Petal.Length=log(iris$Petal.Length), Petal.Width=log(iris$Petal.Width), Speciesiris$Species)
sd(iris.log.scale$Petal.Length) = 1
mean(iris.log.scale$Petal.Length) ?0
#c)
iris.log.scale <- cbind.data.frame(Sepal.Length=scale(iris.log$Sepal.Length), Sepal.Width=scale(iris.log$Sepal.Width), Petal.Length=scale(iris.log$Petal.Length), Petal.Width=scale(iris.log$Petal.Width), Species=iris.log$Species)
# b)
iris.log <- cbind.data.frame(Sepal.Length=log(iris$Sepal.Length), Sepal.Width=log(iris$Sepal.Width), Petal.Length=log(iris$Petal.Length), Petal.Width=log(iris$Petal.Width), Speciesiris$Species)
# b)
iris.log <- cbind.data.frame(Sepal.Length=log(iris$Sepal.Length), Sepal.Width=log(iris$Sepal.Width), Petal.Length=log(iris$Petal.Length), Petal.Width=log(iris$Petal.Width), Speciesiris$Species)
plot(iris.predict$PC1, iris.predict$PC2, type="p", col="red", xlab="PC1", ylab="PC2")
#d)
iris.predict <- predict(iris.pca)
iris.log.scale <- iris.log.scale[,-5]
